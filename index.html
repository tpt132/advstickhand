<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Stickhandling Trainer with Tap Grid</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: #000; color: #fff;
  }
  #video, #canvas {
    position: absolute; top: 0; left: 0;
    object-fit: none; /* no stretching */
  }
  #ui {
    position: absolute; top: 10px; left: 10px; z-index: 10;
    background: rgba(0,0,0,0.7);
    padding: 10px;
    border-radius: 5px;
  }
  button {
    font-size: 18px; padding: 8px 16px; margin-right: 8px;
  }
  #status {
    margin-top: 8px; font-size: 24px;
  }
  #zoneDisplay {
    position: absolute;
    bottom: 20px;
    right: 20px;
    font-size: 72px;
    color: red;
    z-index: 100;
    background: rgba(0,0,0,0.5);
    padding: 10px 20px;
    border-radius: 10px;
  }
</style>
</head>
<body>
<div id="ui">
  <button onclick="start()">Start</button>
  <button onclick="stop()">Stop</button>
  <button onclick="resetGrid()">Reset Grid</button>
  <div id="status">Press Start to begin</div>
  <div style="margin-top:10px; font-size:14px; max-width:320px; color:#ccc;">
    Click twice to place 2 vertical lines, then twice for 2 horizontal lines to create a 3x3 grid.
  </div>
</div>
<div id="zoneDisplay"></div>
<video id="video" autoplay muted playsinline></video>
<canvas id="canvas"></canvas>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest"></script>

<script>
let model, video, canvas, ctx;
let targetZone = null, speaking = false, zoneHit = false;

let verticalLines = [];
let horizontalLines = [];
let placingVertical = true; // true = placing vertical lines, false = horizontal lines

async function start() {
  if (!model) {
    status('Loading model...');
    try {
      model = await cocoSsd.load();
      status('Model ready!');
    } catch (error) {
      status('Model loading failed');
      console.error(error);
      return;
    }
  }
  
  video = document.getElementById('video');
  canvas = document.getElementById('canvas');
  ctx = canvas.getContext('2d');

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ 
      video: { facingMode: 'environment' } 
    });
    video.srcObject = stream;

    video.addEventListener('loadedmetadata', () => {
      // Set canvas size to match video pixel size
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;

      // Set CSS size of video and canvas to match pixel size
      video.style.width = video.videoWidth + 'px';
      video.style.height = video.videoHeight + 'px';
      canvas.style.width = video.videoWidth + 'px';
      canvas.style.height = video.videoHeight + 'px';

      resetGrid();
      requestAnimationFrame(detectLoop);
    });
  } catch (error) {
    status('Camera access denied');
    console.error(error);
    return;
  }

  // Make sure click listener is added only once
  canvas.removeEventListener('click', onCanvasClick);
  canvas.addEventListener('click', onCanvasClick);
}

function stop() {
  if (video && video.srcObject) {
    video.srcObject.getTracks().forEach(t => t.stop());
    video.srcObject = null;
  }
  if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
  status('Stopped');
  document.getElementById('zoneDisplay').textContent = '';
  targetZone = null;
  verticalLines = [];
  horizontalLines = [];
  placingVertical = true;
}

function resetGrid() {
  verticalLines = [];
  horizontalLines = [];
  placingVertical = true;
  zoneHit = false;
  targetZone = null;
  document.getElementById('zoneDisplay').textContent = '';
  status(verticalLines.length === 0 ? 'Click twice for vertical lines' : `${verticalLines.length}/2 vertical lines set`);
}

function status(msg) {
  document.getElementById('status').innerText = msg;
}

function say(text) {
  if (!speaking && 'speechSynthesis' in window) {
    speaking = true;
    const u = new SpeechSynthesisUtterance(text.toString());
    u.onend = () => speaking = false;
    speechSynthesis.speak(u);
  }
}

function nextRound() {
  if (verticalLines.length !== 2 || horizontalLines.length !== 2) {
    targetZone = null;
    return;
  }
  zoneHit = false;
  targetZone = Math.floor(Math.random() * 9) + 1;
  status('Target: ' + targetZone);
  document.getElementById('zoneDisplay').textContent = targetZone;
  say(targetZone);
}

async function detectLoop() {
  if (!model || !video.srcObject || video.readyState < 2) {
    requestAnimationFrame(detectLoop);
    return;
  }
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  // Draw grid lines
  ctx.strokeStyle = 'rgba(255,255,255,0.8)';
  ctx.lineWidth = 3;
  verticalLines.sort((a,b)=>a-b).forEach(x => {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  });
  horizontalLines.sort((a,b)=>a-b).forEach(y => {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  });

  if (verticalLines.length === 2 && horizontalLines.length === 2) {
    try {
      const preds = await model.detect(video);
      
      let puckDetected = false;
      preds.forEach(p => {
        if (p.class === 'sports ball' && p.score > 0.5) {
          puckDetected = true;
          const [x, y, w, h] = p.bbox;
          ctx.strokeStyle = 'lime';
          ctx.lineWidth = 4;
          ctx.strokeRect(x, y, w, h);

          const cx = x + w/2;
          const cy = y + h/2;

          const col = getCol(cx);
          const row = getRow(cy);
          if (col === -1 || row === -1) return;

          const zone = row * 3 + col + 1;
          ctx.fillStyle = 'yellow';
          ctx.font = '30px Arial';
          ctx.fillText(zone, cx, cy - 10);

          if (!zoneHit && targetZone && zone === targetZone) {
            zoneHit = true;
            say('Good!');
            setTimeout(nextRound, 1000);
          }
        }
      });
      
      if (!puckDetected) {
        ctx.fillStyle = 'red';
        ctx.font = '20px Arial';
        ctx.fillText('Puck not detected', 20, 50);
      }
    } catch (error) {
      console.error('Detection error:', error);
    }
  }

  requestAnimationFrame(detectLoop);
}

function getCol(x) {
  if (verticalLines.length !== 2) return -1;
  if (x < verticalLines[0]) return 0;
  if (x < verticalLines[1]) return 1;
  if (x <= canvas.width) return 2;
  return -1;
}

function getRow(y) {
  if (horizontalLines.length !== 2) return -1;
  if (y < horizontalLines[0]) return 0;
  if (y < horizontalLines[1]) return 1;
  if (y <= canvas.height) return 2;
  return -1;
}

function onCanvasClick(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const x = (e.clientX - rect.left) * scaleX;
  const y = (e.clientY - rect.top) * scaleY;

  if (placingVertical) {
    if (verticalLines.length < 2) {
      verticalLines.push(Math.max(0, Math.min(x, canvas.width)));
      status(`Vertical lines: ${verticalLines.length}/2`);
      if (verticalLines.length === 2) {
        placingVertical = false;
        status('Click twice for horizontal lines');
      }
    }
  } else {
    if (horizontalLines.length < 2) {
      horizontalLines.push(Math.max(0, Math.min(y, canvas.height)));
      status(`Horizontal lines: ${horizontalLines.length}/2`);
      if (horizontalLines.length === 2) {
        status('Grid ready! Move puck to target zone.');
        nextRound();
      }
    }
  }
}
</script>
</body>
</html>