<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Tap-to-Draw Grid Stickhandling Trainer</title>
<style>
  body, html { margin:0; padding:0; height:100%; overflow:hidden; background:#000; color:#fff; }
  #video, #canvas { position:absolute; top:0; left:0; width:100%; height:100%; object-fit:cover; }
  #ui { position:absolute; top:10px; left:10px; z-index:10; }
  button { font-size:18px; padding:8px 16px; margin-right:8px; }
  #status { margin-top:8px; font-size:24px; }
</style>
</head>
<body>
<div id="ui">
  <button onclick="start()">Start</button>
  <button onclick="stop()">Stop</button>
  <button onclick="resetGrid()">Reset Grid</button>
  <div id="status"></div>
  <div style="margin-top:10px; font-size:14px; max-width:320px; color:#ccc;">
    Tap twice to place 2 vertical lines, then tap twice for 2 horizontal lines.
  </div>
</div>
<video id="video" autoplay muted playsinline></video>
<canvas id="canvas"></canvas>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest"></script>

<script>
let model, video, canvas, ctx;
let targetZone = null, speaking = false, zoneHit = false;

let verticalLines = [];
let horizontalLines = [];
let placingVertical = true; // true = waiting for vertical lines, false = horizontal lines

async function start() {
  if (!model) {
    status('Loading model...');
    model = await cocoSsd.load();
    status('Model ready!');
  }
  video = document.getElementById('video');
  canvas = document.getElementById('canvas');
  ctx = canvas.getContext('2d');

  const stream = await navigator.mediaDevices.getUserMedia({ video: true });
  video.srcObject = stream;
  video.addEventListener('loadeddata', () => {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    verticalLines = [];
    horizontalLines = [];
    placingVertical = true;
    zoneHit = false;
    targetZone = null;
    status('Tap twice on video to place 2 vertical lines');

    nextRound();
    requestAnimationFrame(detectLoop);
  });

  canvas.addEventListener('click', onCanvasClick);
}

function stop() {
  if (video.srcObject) video.srcObject.getTracks().forEach(t => t.stop());
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  status('');
  targetZone = null;
  verticalLines = [];
  horizontalLines = [];

  canvas.removeEventListener('click', onCanvasClick);
}

function resetGrid() {
  verticalLines = [];
  horizontalLines = [];
  placingVertical = true;
  status('Tap twice on video to place 2 vertical lines');
}

function status(msg) {
  document.getElementById('status').innerText = msg;
}

function say(text) {
  if (!speaking) {
    speaking = true;
    const u = new SpeechSynthesisUtterance(text);
    u.onend = () => speaking = false;
    speechSynthesis.speak(u);
  }
}

function nextRound() {
  if (!verticalLines.length || !horizontalLines.length) {
    targetZone = null;
    return;
  }
  zoneHit = false;
  targetZone = Math.floor(Math.random() * 9) + 1;
  status('Target: ' + targetZone);
  say(targetZone);
}

async function detectLoop() {
  if (!model || !video.srcObject) return;
  ctx.drawImage(video, 0, 0);

  // Draw grid lines if set
  ctx.strokeStyle = 'rgba(255,255,255,0.8)';
  ctx.lineWidth = 3;

  verticalLines.sort((a,b)=>a-b);
  horizontalLines.sort((a,b)=>a-b);

  verticalLines.forEach(x => {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  });
  horizontalLines.forEach(y => {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  });

  // Detect puck and map zone
  if (verticalLines.length === 2 && horizontalLines.length === 2) {
    const preds = await model.detect(video);
    preds.forEach(p => {
      if (p.class === 'sports ball' && p.score > 0.5) {
        const [x, y, w, h] = p.bbox;
        ctx.strokeStyle = 'lime';
        ctx.lineWidth = 4;
        ctx.strokeRect(x, y, w, h);
        const cx = x + w/2, cy = y + h/2;

        const col = getCol(cx);
        const row = getRow(cy);
        if (col === -1 || row === -1) return;

        const zone = row * 3 + col + 1;
        ctx.fillStyle = 'yellow';
        ctx.font = '30px Arial';
        ctx.fillText(zone, cx, cy - 10);

        if (!zoneHit && zone === targetZone) {
          zoneHit = true;
          say('Good');
          setTimeout(nextRound, 1000);
        }
      }
    });
  }

  requestAnimationFrame(detectLoop);
}

function getCol(x) {
  if (x < verticalLines[0]) return 0;
  else if (x < verticalLines[1]) return 1;
  else if (x <= canvas.width) return 2;
  return -1;
}

function getRow(y) {
  if (y < horizontalLines[0]) return 0;
  else if (y < horizontalLines[1]) return 1;
  else if (y <= canvas.height) return 2;
  return -1;
}

function onCanvasClick(e) {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  if (placingVertical) {
    verticalLines.push(x);
    status(`Vertical lines set: ${verticalLines.length}/2`);
    if (verticalLines.length === 2) {
      placingVertical = false;
      status('Tap twice to place 2 horizontal lines');
    }
  } else {
    horizontalLines.push(y);
    status(`Horizontal lines set: ${horizontalLines.length}/2`);
    if (horizontalLines.length === 2) {
      status('Grid set! Starting puck detection.');
      nextRound();
    }
  }
}
</script>
</body>
</html>
