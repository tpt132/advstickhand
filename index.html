<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Hockey Stickhandling Trainer</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: #000; color: #fff;
    font-family: Arial, sans-serif;
  }
  #video, #canvas {
    position: absolute; top: 0; left: 0;
    object-fit: none;
  }
  #ui {
    position: absolute; top: 10px; left: 10px; z-index: 10;
    background: rgba(0,0,0,0.5); padding: 10px; border-radius: 6px;
    max-width: 320px;
  }
  button {
    font-size: 18px; padding: 8px 16px; margin-right: 8px; margin-bottom: 8px;
    cursor: pointer;
  }
  #status {
    margin-top: 8px; font-size: 20px; min-height: 24px;
  }
  #instructions {
    margin-top: 10px; font-size: 14px; color: #ccc;
  }
</style>
</head>
<body>
<div id="ui">
  <button onclick="start()">Start</button>
  <button onclick="stop()">Stop</button>
  <button onclick="resetGrid()">Reset Grid</button>
  <div id="status"></div>
  <div id="instructions">
    Tap twice on the video to set 2 vertical lines.<br/>
    Then tap twice to set 2 horizontal lines.<br/>
    The 3x3 grid will be created.<br/>
    The app will detect the puck and call out numbers 1â€“9.<br/>
    Move the puck into the highlighted target zone.
  </div>
</div>
<video id="video" autoplay muted playsinline></video>
<canvas id="canvas"></canvas>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest"></script>

<script>
let model, video, canvas, ctx;
let targetZone = null, speaking = false, zoneHit = false;

let verticalLines = [];
let horizontalLines = [];
let placingVertical = true;

async function start() {
  if (!model) {
    updateStatus('Loading model...');
    model = await cocoSsd.load();
    updateStatus('Model ready!');
  }
  video = document.getElementById('video');
  canvas = document.getElementById('canvas');
  ctx = canvas.getContext('2d');

  const stream = await navigator.mediaDevices.getUserMedia({ video: true });
  video.srcObject = stream;

  video.addEventListener('loadeddata', () => {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    canvas.style.width = video.videoWidth + 'px';
    canvas.style.height = video.videoHeight + 'px';
    video.style.width = video.videoWidth + 'px';
    video.style.height = video.videoHeight + 'px';

    verticalLines = [];
    horizontalLines = [];
    placingVertical = true;
    zoneHit = false;
    targetZone = null;

    updateStatus('Tap twice on video to place 2 vertical lines');

    nextRound();
    requestAnimationFrame(detectLoop);
  }, { once: true });

  canvas.removeEventListener('click', onCanvasClick);
  canvas.addEventListener('click', onCanvasClick);
}

function stop() {
  if (video && video.srcObject) {
    video.srcObject.getTracks().forEach(t => t.stop());
  }
  if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
  updateStatus('');
  targetZone = null;
  verticalLines = [];
  horizontalLines = [];
  placingVertical = true;
  canvas.removeEventListener('click', onCanvasClick);
}

function resetGrid() {
  verticalLines = [];
  horizontalLines = [];
  placingVertical = true;
  updateStatus('Tap twice on video to place 2 vertical lines');
}

function updateStatus(msg) {
  document.getElementById('status').innerText = msg;
}

function say(text) {
  if (!speaking) {
    speaking = true;
    const u = new SpeechSynthesisUtterance(text);
    u.onend = () => speaking = false;
    speechSynthesis.speak(u);
  }
}

function nextRound() {
  if (verticalLines.length !== 2 || horizontalLines.length !== 2) {
    targetZone = null;
    return;
  }
  zoneHit = false;
  targetZone = Math.floor(Math.random() * 9) + 1;
  updateStatus('Target: ' + targetZone);
  say(targetZone);
}

async function detectLoop() {
  if (!model || !video.srcObject) {
    requestAnimationFrame(detectLoop);
    return;
  }
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  ctx.strokeStyle = 'rgba(255,255,255,0.8)';
  ctx.lineWidth = 3;

  verticalLines.sort((a,b)=>a-b).forEach(x => {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  });
  horizontalLines.sort((a,b)=>a-b).forEach(y => {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  });

  if (verticalLines.length === 2 && horizontalLines.length === 2) {
    const preds = await model.detect(video);

    verticalLines.sort((a,b)=>a-b);
    horizontalLines.sort((a,b)=>a-b);

    const zones = [];
    for (let row=0; row<3; row++) {
      for (let col=0; col<3; col++) {
        const x1 = col === 0 ? 0 : verticalLines[col-1];
        const x2 = col === 2 ? canvas.width : verticalLines[col];
        const y1 = row === 0 ? 0 : horizontalLines[row-1];
        const y2 = row === 2 ? canvas.height : horizontalLines[row];
        zones.push({x1, y1, x2, y2});
      }
    }

    // Draw the highlighted target zone
    if (targetZone) {
      const z = zones[targetZone - 1];
      ctx.fillStyle = 'rgba(0, 255, 0, 0.25)';
      ctx.fillRect(z.x1, z.y1, z.x2 - z.x1, z.y2 - z.y1);
    }

    preds.forEach(p => {
      if (p.class === 'sports ball' && p.score > 0.5) {
        const [x, y, w, h] = p.bbox;
        ctx.strokeStyle = 'lime';
        ctx.lineWidth = 4;
        ctx.strokeRect(x, y, w, h);

        const cx = x + w/2;
        const cy = y + h/2;

        // Zone detection with margin tolerance
        const margin = 10;
        let col = -1, row = -1;

        for(let c=0; c<3; c++) {
          const left = (c === 0 ? 0 : verticalLines[c-1]) - margin;
          const right = (c === 2 ? canvas.width : verticalLines[c]) + margin;
          if (cx >= left && cx <= right) {
            col = c;
            break;
          }
        }
        for(let r=0; r<3; r++) {
          const top = (r === 0 ? 0 : horizontalLines[r-1]) - margin;
          const bottom = (r === 2 ? canvas.height : horizontalLines[r]) + margin;
          if (cy >= top && cy <= bottom) {
            row = r;
            break;
          }
        }

        if (col === -1 || row === -1) return;

        const zone = row * 3 + col + 1;
        ctx.fillStyle = 'yellow';
        ctx.font = '30px Arial';
        ctx.fillText(zone, cx, cy - 10);

        if (!zoneHit && zone === targetZone) {
          zoneHit = true;
          say('Good');
          setTimeout(nextRound, 1000);
        }
      }
    });
  }

  requestAnimationFrame(detectLoop);
}

function onCanvasClick(e) {
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width / rect.width);
  const y = (e.clientY - rect.top) * (canvas.height / rect.height);

  if (placingVertical) {
    if (verticalLines.length < 2) {
      verticalLines.push(x);
      updateStatus(`Vertical lines set: ${verticalLines.length}/2`);
      if (verticalLines.length === 2) {
        placingVertical = false;
        updateStatus('Tap twice to place 2 horizontal lines');
      }
    }
  } else {
    if (horizontalLines.length < 2) {
      horizontalLines.push(y);
      updateStatus(`Horizontal lines set: ${horizontalLines.length}/2`);
      if (horizontalLines.length === 2) {
        updateStatus('Grid set! Starting puck detection.');
        nextRound();
      }
    }
  }
}
</script>
</body>
</html>
